package record

import (
	"bytes"
	"encoding/binary"
)

// ref. https://datatracker.ietf.org/doc/html/rfc8446#section-5.1
// struct {
// 	ContentType type;
// 	ProtocolVersion legacy_record_version;
// 	uint16 length;
// 	opaque fragment[TLSPlaintext.length];
// } TLSPlaintext;

type TLSPlainText struct {
	// The higher-level protocol used to process the enclosed fragment.
	contentType ContentType
	//  legacy_record_version: MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello (i.e., one not generated after a HelloRetryRequest), where it MAY also be 0x0301 for compatibility purposes. This field is deprecated and MUST be ignored for all purposes. Previous versions of TLS would use other values in this field under some circumstances.
	legacyRecordVersion uint16
	// The length (in bytes) of the following TLSPlaintext.fragment. The length MUST NOT exceed 2^14 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a "record_overflow" alert.
	length uint16
	// The data being transmitted. This value is transparent and is treated as an independent block to be dealt with by the higher- level protocol specified by the type field.
	fragment []byte
}

func NewTLSPlainText(contentType ContentType, fragment []byte) TLSPlainText {
	return TLSPlainText{
		contentType:         contentType,
		legacyRecordVersion: 0x0303,
		length:              uint16(len(fragment)),
		fragment:            fragment,
	}
}

func (t TLSPlainText) Encode() []byte {
	encoded := []byte{}

	// type
	encoded = append(encoded, t.contentType.Encode())

	// legacyRecordVersion
	vertionBytes := make([]byte, 2)
	binary.BigEndian.PutUint16(vertionBytes, t.legacyRecordVersion)
	encoded = append(encoded, vertionBytes...)

	// length
	lengthBytes := make([]byte, 2)
	binary.BigEndian.PutUint16(lengthBytes, t.length)
	encoded = append(encoded, lengthBytes...)

	// fragment
	encoded = append(encoded, t.fragment...)

	return encoded
}

func (t TLSPlainText) Fragment() []byte {
	return t.fragment
}

func DecodeTLSPlainText(data []byte) TLSPlainText {

	// type
	var contentType ContentType
	data, contentType = DecodeContentType(data)

	// legacyRecordVersion
	legacyRecordVersionByte := data[:2]
	var legacyRecordVersion uint16
	binary.Read(bytes.NewReader(legacyRecordVersionByte), binary.BigEndian, &legacyRecordVersion)
	data = data[2:]

	// length
	lengthByte := data[:2]
	var length uint16
	binary.Read(bytes.NewReader(lengthByte), binary.BigEndian, &length)
	data = data[2:]

	// fragment
	fragment := data[:length]
	_ = data[length:]

	return TLSPlainText{
		contentType:         contentType,
		legacyRecordVersion: legacyRecordVersion,
		length:              length,
		fragment:            fragment,
	}
}
