package record

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"fmt"
	"reflect"
	"testing"

	"github.com/inabajunmr/ttllss/tls/handshake"
)

func TestEncodeAndDecode(t *testing.T) {

	cipherSuites := []handshake.CipherSuite{handshake.TLS_AES_128_GCM_SHA256}
	supportedVersionsExtension := handshake.NewSupportedVersionsForClient(
		[]handshake.ProtocolVersion{0x0304},
	)

	supportedGroupsExtension := handshake.NewSupportedGroupsExtention([]handshake.NamedGroup{handshake.Secp256r1})

	var clientShares []handshake.KeyShareEntry
	curve := elliptic.P256()
	privKey, err := ecdsa.GenerateKey(curve, rand.Reader)
	if err != nil {
		panic(err)
	}
	pubKey := privKey.PublicKey
	keyShareBytes := elliptic.Marshal(curve, pubKey.X, pubKey.Y)
	clientShares = append(clientShares, handshake.NewKeyShareEntry(handshake.Secp256r1, keyShareBytes))
	keyShareExtension := handshake.NewKeyShareClientHello(clientShares)

	ch := handshake.NewClientHello(cipherSuites, []handshake.Extension{supportedVersionsExtension, supportedGroupsExtension, keyShareExtension})
	re := NewTLSPlainText(HandShake, ch.Encode())

	encoded := re.Encode()
	decoded := DecodeTLSPlainText(encoded)

	if re.contentType != decoded.contentType {
		t.Fatalf("contentType original:%v decoded:%v", re.contentType, decoded.contentType)
	}
	if re.legacyRecordVersion != decoded.legacyRecordVersion {
		t.Fatalf("legacyRecordVersion original:%v decoded:%v", re.legacyRecordVersion, decoded.legacyRecordVersion)
	}
	if re.length != decoded.length {
		t.Fatalf("length original:%v decoded:%v", re.length, decoded.length)
	}
	if !reflect.DeepEqual(re.fragment, decoded.fragment) {
		t.Fatalf("fragment original:%x decoded:%x", re.fragment, decoded.fragment)
	}

}

func Test(t *testing.T) {

	record := []byte{
		0x16, 0x03, 0x03, 0x00, 0x94 /** ここから fragment? **/, 0x01, 0x00, 0x00, 0x90, 0x03, 0x03, 0xf0, 0x5d,
		0x41, 0x2d, 0x24, 0x35, 0x27, 0xfd, 0x90, 0xb5, 0xb4, 0x24, 0x9d, 0x4a, 0x69,
		0xf8, 0x97, 0xb5, 0xcf, 0xfe, 0xe3, 0x8d, 0x4c, 0xec, 0xc7, 0x8f, 0xd0, 0x25,
		0xc6, 0xeb, 0xe1, 0x33, 0x20, 0x67, 0x7e, 0xb6, 0x52, 0xad, 0x12, 0x51, 0xda,
		0x7a, 0xe4, 0x5d, 0x3f, 0x19, 0x2c, 0xd1, 0xbf, 0xaf, 0xca, 0xa8, 0xc5, 0xfe,
		0x59, 0x2f, 0x1b, 0x2f, 0x2a, 0x96, 0x1e, 0x12, 0x83, 0x35, 0xae, 0x00, 0x02,
		0x13, 0x02, 0x01, 0x00, 0x00, 0x45, 0x00, 0x2b, 0x00, 0x03, 0x02, 0x03, 0x04,
		0x00, 0x0a, 0x00, 0x06, 0x00, 0x04, 0x00, 0x1d, 0x00, 0x17, 0x00, 0x33, 0x00,
		0x26, 0x00, 0x24, 0x00, 0x1d, 0x00, 0x20, 0x49, 0x51, 0x50, 0xa9, 0x0a, 0x47,
		0x82, 0xfe, 0xa7, 0x47, 0xf5, 0xcb, 0x55, 0x19, 0xdc, 0xf0, 0xce, 0x0d, 0xee,
		0x9c, 0xdc, 0x04, 0x93, 0xbd, 0x84, 0x9e, 0xea, 0xf7, 0xd3, 0x93, 0x64, 0x2f,
		0x00, 0x0d, 0x00, 0x06, 0x00, 0x04, 0x04, 0x03, 0x08, 0x07,
	}

	decoded := DecodeTLSPlainText(record)

	fmt.Printf("%+v", decoded)

	// ここで落ちるのはおかしい
	// 自分の解釈だと fragment の位置がずれてるのでなんか変（0x03 から fragment のはず）
	// これは Handshake Header らしい
	// この層がまるごと抜けている https://datatracker.ietf.org/doc/html/rfc8446#section-4
	t.Fatalf("%+v", handshake.DecodeClientHello(decoded.fragment))
}
